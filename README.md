# Design Patterns with Go

Here we explore all possible design patterns that would work with Golang.
And see if this even makes sense at all 👨‍🔬

Here's what we plan to go through, and we've achieved so far:

- SOLID
    - [x] Single Responsibility Principle (**SRP**)
    - [x] Open-Closed Principle (**OCP**)
    - [x] Liskov Substitution Principle (**LSP**)
    - [x] Interface Segregation Principle (**ISP**)
    - [x] Dependency Inversion Principle (**DIP**)

> Useful principles of not so useful object-oriented design

- Builder
    - [x] Builder
    - [x] Builder Facets
    - [x] Builder Parameter
    - [x] Functional Builder

> When constructing gets a little bit to complicated

- Factories
    - [x] Factory Function
    - [x] Interface Factory
    - [x] Factory Generator
    - [x] Prototype Factory

> Ways of controlling how an object is constructed

- Prototype
    - [X] Deep Copying
    - [X] Deep Method
    - [x] Copy Through Serialization
    - [x] Prototype Factory

> When it's easier to copy an existing object to fully initialize a new one

- Singleton
    - [x] Singleton
    - [x] Problems with Sinlgeton
    - [x] Sinlgeton and Dependency Inversion

> A design pattern everyone loves to hate... but is it really that bad?

- Adapter
    - [x] Adapter
    - [x] Adapter Caching

> Getting the interface you want from the interface you have

- Bridge
    - [x] Bridge

> Connecting components together through abstractions

- Composite
    - [x] Geometric Shapes
    - [x] Neural Networks

> Treating individual and aggregate objects uniformly

- Decorator
    - [x] Multiple Aggregation
    - [ ] Decorator

> Adding behaviour without altering the type itself

More to come 🚀